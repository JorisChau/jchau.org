---
title: Tracking Stan sampling progress in Shiny
author: Joris Chau
date: '2021-02-02'
slug: tracking-stan-sampling-progress-shiny
categories:
  - R
  - Stan
  - R-bloggers
tags:
  - shiny
  - Stan
  - R
  - callr
  - asynchronous
subtitle: 'A simple approach using `callr`'
summary: ''
authors: []
lastmod: '2021-02-02T21:46:12+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: true
projects: []
---

<script src="{{< blogdown/postref >}}index_files/htmlwidgets/htmlwidgets.js"></script>
<script src="{{< blogdown/postref >}}index_files/d3/d3.min.js"></script>
<script src="{{< blogdown/postref >}}index_files/dagre/dagre-d3.min.js"></script>
<link href="{{< blogdown/postref >}}index_files/mermaid/dist/mermaid.css" rel="stylesheet" />
<script src="{{< blogdown/postref >}}index_files/mermaid/dist/mermaid.slim.min.js"></script>
<link href="{{< blogdown/postref >}}index_files/DiagrammeR-styles/styles.css" rel="stylesheet" />
<script src="{{< blogdown/postref >}}index_files/chromatography/chromatography.js"></script>
<script src="{{< blogdown/postref >}}index_files/DiagrammeR-binding/DiagrammeR.js"></script>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The <a href="/2021/02/01/running-stan-models-in-shiny">previous post</a> demonstrates the use of pre-compiled <a href="https://mc-stan.org/">Stan</a> models in interactive <a href="https://shiny.rstudio.com/">R Shiny</a> applications to avoid unnecessary Stan model (re-)compilation on application start-up. In this short follow-up post we go a step further and tackle the issue of tracking the Stan model sampling progress itself in a shiny-application. The idea, mainly inspired by <a href="https://discindo.org/post/asynchronous-execution-in-shiny/">this blog post</a>, is to execute the Stan model sampling in a separate background R process using the convenient <a href="https://callr.r-lib.org/"><code>callr</code></a>-package to avoid blocking of the shiny-application.</p>
<div id="demo-shiny-app" class="section level2">
<h2>Demo Shiny-app</h2>
<p>For illustration purposes, we start from the basic shiny-app in the previous post that fits a simple linear model in Stan and plots the sampled posteriors:</p>
<pre class="r"><code>library(shiny)

ui &lt;- fluidPage(
  sidebarLayout(
    sidebarPanel(
      numericInput(&quot;N&quot;, label = &quot;N&quot;, value = 10)
    ),
    mainPanel(
      plotOutput(&quot;posteriors&quot;)
    )
  )
)

server &lt;- function(input, output, session) {
  ## draw samples 
  draws &lt;- reactive({
    N &lt;- input$N
    rstan::sampling(
      object = shinyStanModels:::stanmodels[[&quot;lm&quot;]],
      data = list(N = N, x = seq_len(N), y = rnorm(N, seq_len(N), 0.1)),
      chains = 2,
      iter = 1000
    )
  })
  ## plot histograms
  output$posteriors &lt;- renderPlot({
    req(draws())
    op &lt;- par(mfrow = c(1, 2), cex = 1.25)
    hist(rstan::extract(draws(), &quot;alpha&quot;)[[1]], main = bquote(&quot;Posterior samples&quot;~alpha), xlab = expression(alpha))
    hist(rstan::extract(draws(), &quot;beta&quot;)[[1]], main = bquote(&quot;Posterior samples&quot;~beta), xlab = expression(beta))
    par(op)
  })
  
}

shinyApp(ui = ui, server = server)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/app.gif" /></p>
<p><strong>Note</strong>: here the pre-compiled <code>"lm"</code> Stan model is called from a dummy R-package <code>shinyStanModels</code> as explained <a href="%5Bprevious%20post%5D(/2021/02/01/running-stan-models-in-shiny)">previously</a> to avoid model recompilation every time the shiny-app is launched.</p>
</div>
<div id="shiny-app-blocking" class="section level2">
<h2>Shiny-app blocking</h2>
<p>By increasing the number observations <span class="math inline">\(N\)</span>, we also increase the execution time of the MCMC sampling process. Setting e.g. <span class="math inline">\(N = 500\)</span>, it already takes quite a while for the computations to complete<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. Unfortunately, there is no way to tell from the shiny-app whether the sampling iterations are progressing quickly or still require a long time to finish. In an interactive R-session, the progress of the sampling iterations across individual chains is either printed to the console (that is, the current <code>stdout</code> connection) or to a temporary file when multiple chains are being sampled in parallel. It would be great if we could divert these progress messages to the shiny-app itself, so that the sampling iterations can be tracked in real-time in the same way as in any interactive R-session.</p>
<p>A first idea that comes to mind is to make use of shiny’s <code>reactivePoll()</code> or <code>reactiveFileReader()</code> to periodically read the contents of the temporary progress file generated by Stan, and display these contents in reactively in the shiny-app. The problem, however, is that due to shiny’s synchronous reactive nature the shiny-app is effectively <strong>blocked</strong> while executing the sampling process, and the <code>reactiveFileReader()</code> will only have a chance to read the progress file when the model sampling is already finished, thereby defeating its purpose.</p>
<p>Instead, we have to somehow detach the slow model sampling process from the main shiny-app process so that both processes do not interfere with each other and the shiny-app is free to execute other requests. In fact, what is needed is a way to launch the sampling process in a separate background R-process, and, as it turns out, this is exactly what is provided by the convenient <code>callr</code>-package.</p>
</div>
</div>
<div id="unblocking-a-shiny-app-with-callr" class="section level1">
<h1>Unblocking a shiny-app with <code>callr</code></h1>
<p>In order to execute the Stan model sampling procedure in a separate R-process, we wrap the call to <code>rstan::sampling()</code> in a function and pass it to the <code>func</code> argument of <code>callr::r_bg()</code>. The function is evaluated in a background R-process and may take a long time to complete, but <code>callr::r_bg()</code> <strong>immediately</strong> returns control to the current R-process so that it is free to perform other operations:</p>
<pre class="r"><code>library(callr)

## launch job in separate R process
r_process &lt;- r_bg(
  func = function(N) {
    rstan::sampling(
      object = shinyStanModels:::stanmodels[[&quot;lm&quot;]],
      data = list(N = N, x = seq_len(N), y = rnorm(N, seq_len(N), 0.1)),
      open_progress = FALSE,
      chains = 2,
      iter = 1000
    )
  },
  args = list(N = 500)
)

## the process object is returned immediately
## and can be polled from the current R process
r_process
#&gt; PROCESS &#39;R&#39;, running, pid 27966.

## check if job is still running
r_process$is_alive()
#&gt; [1] TRUE

## result is not yet available
tryCatch(r_process$get_result(), error = function(e) e$message)
#&gt; [1] &quot;Still alive&quot;

## extract the result when the job is finished
system.time({
  r_process$wait()
})
#&gt;    user  system elapsed 
#&gt;  25.697   0.102  25.716
r_process
#&gt; PROCESS &#39;R&#39;, finished.
r_process$get_result()
#&gt; Inference for Stan model: lm.
#&gt; 2 chains, each with iter=1000; warmup=500; thin=1; 
#&gt; post-warmup draws per chain=500, total post-warmup draws=1000.
#&gt; 
#&gt;         mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat
#&gt; alpha   0.00    0.00 0.01  -0.02  -0.01   0.00   0.01   0.02   382 1.00
#&gt; beta    1.00    0.00 0.00   1.00   1.00   1.00   1.00   1.00   473 1.00
#&gt; sigma   0.10    0.00 0.00   0.10   0.10   0.10   0.11   0.11   345 1.01
#&gt; lp__  876.27    0.07 1.18 873.03 875.81 876.53 877.09 877.60   310 1.00
#&gt; 
#&gt; Samples were drawn using NUTS(diag_e) at Sun Feb 28 13:53:14 2021.
#&gt; For each parameter, n_eff is a crude measure of effective sample size,
#&gt; and Rhat is the potential scale reduction factor on split chains (at 
#&gt; convergence, Rhat=1).</code></pre>
<p><strong>Note</strong>: launching a separate R-process does not necessarily require a multi-core processor and also works using only a single-core processor. On the other hand, the R-session does need to have sufficient permission/rights to launch a separate R-process on the system.</p>
<div id="demo-shiny-app-continued" class="section level2">
<h2>Demo Shiny-app (continued)</h2>
<p>In a first step, we update the shiny-app by wrapping the <code>rstan::sampling()</code> call in a call to <code>callr::r_bg()</code> so that the execution of the model sampling no longer blocks the shiny-app process. Using the <code>stdout</code> argument of <code>callr::r_bg()</code> we can divert<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> all messages generated by <code>rstan::sampling()</code> (and printed to <code>stdout</code>) to a temporary file <code>tfile</code>.</p>
<p>Whenever the number of observations <span class="math inline">\(N\)</span> is changed and a new background R-process is launched, we instruct the shiny-app to start polling the process object (<code>r$bg_process</code>) by updating the reactive value <code>r$poll</code>. This will trigger an observer to: (1) read and assign the contents of the progress file <code>tfile</code> to a reactive value <code>r$progress</code> whenever the progress file has been modified; (2) check if the background process has finished executing and if this is the case retrieve the sampling results. The observer will be re-executed every second and only stops re-executing when the background process is no longer alive and <code>r$poll</code> has been turned off (i.e. set to <code>FALSE</code>).</p>
<p>The progress messages can now be rendered in real-time in the shiny-app by simply pasting the contents of the reactive value <code>r$progress</code>. The posterior histograms only need to be updated whenever new sampling results are available in the reactive value <code>r$draws</code>.</p>
<p>In short, we can summarize the updated shiny-app with the following graph:</p>
<div id="htmlwidget-1" style="width:100%;height:350px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"diagram":"\ngraph TB\n   A[Update N] --> B[Start sampling in background process];\n   B --> B2[Background process is alive?];\n   B2 -->|Yes| C[\"Read progress file (if modified)\"];\n   C --> B2;\n   B2 -->|No| F1[Extract sampling results];\n   F1 --> G[Plot posterior histograms];\n  "},"evals":[],"jsHooks":[]}</script>
<p>More importantly, the updated shiny-app –including model sampling progress– now looks as follows:</p>
<pre class="r"><code>library(shiny)

ui &lt;- fluidPage(
  sidebarLayout(
    sidebarPanel(
      numericInput(&quot;N&quot;, label = &quot;N&quot;, value = 10)
    ),
    mainPanel(
      plotOutput(&quot;posteriors&quot;),
      hr(),
      ## limit the height of the progress message box
      tags$head(tags$style(&quot;#progress{overflow-y:scroll; max-height: 500px;}&quot;)),
      verbatimTextOutput(&quot;progress&quot;)
    )
  )
)

server &lt;- function(input, output, session) {
  
  ## file to write progress
  tfile &lt;- tempfile(fileext = &quot;.txt&quot;)
  
  ## reactive values
  r &lt;- reactiveValues(
    progress_mtime = -1
  )
  
  observeEvent(input$N, {
    ## start sampling in background process
    r$bg_process &lt;- callr::r_bg(
      ## this is a long running computation
      func = function(N) {
        rstan::sampling(
          object = shinyStanModels:::stanmodels[[&quot;lm&quot;]],
          data = list(N = N, x = seq_len(N), y = rnorm(N, seq_len(N), 0.1)),
          open_progress = FALSE,
          iter = 1000,
          chains = 2
        )
      },
      args = list(N = input$N),
      stdout = tfile,
      supervise = TRUE
    )
    ## start polling bg process
    r$poll &lt;- TRUE   
  })
  
  ## observe status of bg process
  observe({
    req(r$bg_process, r$poll)
    ## keep re-executing observer as 
    ## long as bg process is running
    invalidateLater(millis = 1000, session)
    ## read current progress if file is modified
    mtime &lt;- file.info(tfile)$mtime
    if(mtime &gt; r$progress_mtime) {
      r$progress &lt;- readLines(tfile) 
      r$progress_mtime &lt;- mtime
    }
    ## extract draws when bg process is finished
    if(!r$bg_process$is_alive()) {
      r$draws &lt;- r$bg_process$get_result()
      r$poll &lt;- FALSE  ## stop polling bg process
    } 
  })
  
  ## plot histograms
  output$posteriors &lt;- renderPlot({
    req(r$draws)
    op &lt;- par(mfrow = c(1, 2), cex = 1.25)
    hist(rstan::extract(r$draws, &quot;alpha&quot;)[[1]], main = bquote(&quot;Posterior samples&quot;~alpha), xlab = expression(alpha))
    hist(rstan::extract(r$draws, &quot;beta&quot;)[[1]], main = bquote(&quot;Posterior samples&quot;~beta), xlab = expression(beta))
    par(op)
  })
  
  ## print progress
  output$progress &lt;- renderText({
    req(r$progress)
    paste(r$progress, collapse = &quot;\n&quot;)
  })
  
}

shinyApp(ui = ui, server = server)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-5"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/app1.gif" alt="Progress of sampling iterations with two chains (in parallel) on a multi-core processor" width="100%" />
<p class="caption">
Figure 1: Progress of sampling iterations with two chains (in parallel) on a multi-core processor
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-6"></span>
<img src="{{< blogdown/postref >}}index_files/figure-html/app2.gif" alt="Progress of sampling iterations with two chains (in sequence) on a single-core processor[^3]" width="100%" />
<p class="caption">
Figure 2: Progress of sampling iterations with two chains (in sequence) on a single-core processor<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>
</p>
</div>
</div>
</div>
<div id="session-info" class="section level1">
<h1>Session Info</h1>
<pre><code>#&gt; R version 4.0.2 (2020-06-22)
#&gt; Platform: x86_64-pc-linux-gnu (64-bit)
#&gt; Running under: Ubuntu 18.04.5 LTS
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1
#&gt; LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1
#&gt; 
#&gt; locale:
#&gt;  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
#&gt;  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
#&gt;  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
#&gt;  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
#&gt;  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
#&gt; [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] callr_3.5.1
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] rstan_2.21.2         tidyselect_1.1.0     xfun_0.21           
#&gt;  [4] bslib_0.2.4          purrr_0.3.4          V8_3.4.0            
#&gt;  [7] colorspace_2.0-0     vctrs_0.3.6          generics_0.1.0      
#&gt; [10] htmltools_0.5.1.1    stats4_4.0.2         loo_2.4.1           
#&gt; [13] yaml_2.2.1           rlang_0.4.10         pkgbuild_1.2.0      
#&gt; [16] jquerylib_0.1.3      pillar_1.4.7         DBI_1.1.1           
#&gt; [19] glue_1.4.2           withr_2.4.1          RColorBrewer_1.1-2  
#&gt; [22] matrixStats_0.58.0   lifecycle_0.2.0      stringr_1.4.0       
#&gt; [25] munsell_0.5.0        blogdown_1.1.7       gtable_0.3.0        
#&gt; [28] visNetwork_2.0.9     htmlwidgets_1.5.3    codetools_0.2-16    
#&gt; [31] evaluate_0.14        inline_0.3.17        knitr_1.31          
#&gt; [34] ps_1.5.0             shinyStanModels_0.1  DiagrammeR_1.0.6.1  
#&gt; [37] parallel_4.0.2       curl_4.3             highr_0.8           
#&gt; [40] Rcpp_1.0.6           scales_1.1.1         RcppParallel_5.0.2  
#&gt; [43] StanHeaders_2.21.0-7 jsonlite_1.7.2       gridExtra_2.3       
#&gt; [46] ggplot2_3.3.3        digest_0.6.27        stringi_1.5.3       
#&gt; [49] bookdown_0.21        processx_3.4.5       dplyr_1.0.4         
#&gt; [52] grid_4.0.2           cli_2.3.0            tools_4.0.2         
#&gt; [55] magrittr_2.0.1       sass_0.3.1           tibble_3.0.6        
#&gt; [58] crayon_1.4.1         pkgconfig_2.0.3      ellipsis_0.3.1      
#&gt; [61] prettyunits_1.1.1    assertthat_0.2.1     rmarkdown_2.6.6     
#&gt; [64] R6_2.5.0             compiler_4.0.2</code></pre>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>this Stan program could be made more efficient by specifying reasonable priors, but that is not the purpose of this illustration.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>this approach also works when multiple chains are sampled in parallel, i.e. if the <code>cores</code> argument in <code>rstan::sampling()</code> is larger than 1.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>here the shiny-app is launched in an isolated docker container with a limit on the cpu-usage (<a href="https://docs.docker.com/config/containers/resource_constraints/#cpu" class="uri">https://docs.docker.com/config/containers/resource_constraints/#cpu</a>)<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
